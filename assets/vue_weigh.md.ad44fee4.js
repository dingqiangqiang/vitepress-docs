import{_ as s,c as n,o as a,V as l}from"./chunks/framework.85f79a96.js";const p="/vitepress-docs/assets/compare.06d00b42.png",e="/vitepress-docs/assets/compare1.1d7a7a5e.jpeg",o="/vitepress-docs/assets/compare3.345448a5.jpeg",r="/vitepress-docs/assets/compare4.d5acf580.jpeg",c="/vitepress-docs/assets/compiler2.5b4bac04.png",t="/vitepress-docs/assets/compiler.ba30b443.png",M=JSON.parse('{"title":"权衡的艺术","description":"","frontmatter":{},"headers":[],"relativePath":"vue/weigh.md","filePath":"vue/weigh.md","lastUpdated":1688386541000}'),i={name:"vue/weigh.md"},E=l(`<h1 id="权衡的艺术" tabindex="-1">权衡的艺术 <a class="header-anchor" href="#权衡的艺术" aria-label="Permalink to &quot;权衡的艺术&quot;">​</a></h1><p><strong>框架的设计过程其实是一个不断取舍的过程</strong></p><h2 id="编程范式" tabindex="-1">编程范式 <a class="header-anchor" href="#编程范式" aria-label="Permalink to &quot;编程范式&quot;">​</a></h2><ul><li>1、<strong>命令式</strong></li></ul><p>特点：<strong>关注过程</strong></p><p>例如: 获取 <code>id</code> 为 <code>app</code> 的 <code>div</code> 标签，它的文本内容为 <code>hello world</code>，为其绑定点击事件，当点击时弹出提示: <code>ok</code></p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">divEle</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">querySelector</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;#app&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">divEle.innerText </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;hello world&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">divEle.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;click&#39;</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">alert</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;click&#39;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>自然语言描述能够与代码产生一一对应的关系，<strong>代码本身描述的是做事的过程</strong>。</p><ul><li>2、<strong>声明式</strong></li></ul><p>特点：<strong>关注结果</strong>。</p><p>用 <code>Vue.js</code> 实现如上功能：</p><div class="language-vue line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;"> @</span><span style="color:#B392F0;">click</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">alert</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;ok&#39;</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">&gt;hello world&lt;/</span><span style="color:#85E89D;">div</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>可以看到，我们提供的是一个&quot;结果&quot;，至于如何实现这个&quot;结果&quot;，我们并不关心，实现该结果的<strong>过程</strong>，则是由 <code>Vue.js</code> 帮我们完成的。</p><p>换句话说， <code>Vue.js</code> 帮我们封装了<strong>过程</strong>。因此我们能够猜到 <code>Vue.js</code> 的内部实现一定是<strong>命令式</strong>的，而暴露给用户的却更加<strong>声明式</strong>。</p><div class="tip custom-block"><p class="custom-block-title">命令式 vs 声明式</p><p><strong>性能</strong>： 命令式的性能 &gt; 声明式的性能</p><p><strong>可维护性</strong>：命令式的可维护性 &lt; 声明式的可维护性</p></div><h2 id="企业应用的开发与设计原则" tabindex="-1">企业应用的开发与设计原则 <a class="header-anchor" href="#企业应用的开发与设计原则" aria-label="Permalink to &quot;企业应用的开发与设计原则&quot;">​</a></h2><ul><li>1、<strong>项目成本</strong></li></ul><p>决定项目成本的是<strong>开发周期</strong>，开发周期越长，所付出的人员成本就会越高，从而导致项目成本变的越高。</p><p>由于声明式的开发范式在可维护性上是大于命令式的，它从一定程度上就决定了，它会使项目的: <strong>开发周期变短、升级变得更容易</strong>，从而大量节约开发成本。</p><ul><li>2、<strong>开发体验</strong></li></ul><p>心智负担可以作为衡量开发难易度的一个标准，心智负担高则证明开发的难度越高，低则表示开发的难度较低，开发更加舒服。</p><p>由于声明式的开发难度明显低于命令式的开发难度，所以对于开发体验而言，<strong>声明式的开发体验更好</strong>，也就是心智负担更低。</p><p>因此在企业级项目开发中，<strong>声明式明显优于命令式</strong></p><h2 id="虚拟dom的性能到底如何" tabindex="-1">虚拟DOM的性能到底如何 <a class="header-anchor" href="#虚拟dom的性能到底如何" aria-label="Permalink to &quot;虚拟DOM的性能到底如何&quot;">​</a></h2><p>在早年使用 jQuery 或者直接使用 Javascript 编写页面的时候，使用 innerHTML 来操作页面非常常见。其实我们可以思考一下：<strong>使用 innerHTML 操作页面和虚拟DOM相比性能如何</strong>? 为了比较性能，我们需要了解两者创建、更新页面的过程。</p><h3 id="创建页面" tabindex="-1">创建页面 <a class="header-anchor" href="#创建页面" aria-label="Permalink to &quot;创建页面&quot;">​</a></h3><ul><li>1、innerHTML</li></ul><p>为了创建页面，我们需要构造一段 HTML 字符串：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">html</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">\`&lt;div&gt;&lt;span&gt;...&lt;/span&gt;&lt;/div&gt;\`</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>接着将该字符串赋值给 DOM 元素的 innerHTML 属性:</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#E1E4E8;">div.innerHTML </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> html</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然而这句话远没有看上去那么简单。为了渲染出页面，首先要把字符串解析成 DOM 树，这是一个 DOM 层面的计算。我们知道，涉及 DOM 的运算要远比 JavaScript 层面的计算性能差，这有一个跑分结果可供参考(上边是纯 JavaScript 层面的计算，循环 10000 次，每次创建一个 JavaScript 对象并将其添加到数组中；下边是 DOM 操作，每次创建一个 DOM 元素并将其添加到页面中)。如下图所示:</p><p><img src="`+p+'" alt="An image"></p><p>跑分结果显示，纯 JavaScript 层面的操作要比 DOM 操作快得多，它们不在一个数量级上。基于这个背景，我们可以用一个公式来表达通过 innerHTML 创建页面的性能 = <strong>HTML 字符串拼接的计算量 + innerHTML 的 DOM 计算量</strong></p><ul><li>2、虚拟 DOM</li></ul><p>虚拟 DOM 创建页面的过程分为两步：第一步是创建 JavaScript 对象，这个对象可以理解为对真实 DOM 的描述；第二步是递归地遍历虚拟 DOM 树并创建真实 DOM。虚拟 DOM 创建页面的性能 = <strong>创建 JavaScript 对象的计算量 + 创建真实 DOM 的计算量</strong></p><p>下图直观地对比了 innerHTML 和虚拟 DOM 在创建页面时的性能</p><p><img src="'+e+'" alt="An image"></p><p>可以看到，无论是纯 JavaScript 层面的计算还是 DOM 层面的计算，其实两者差距不大。这里我们从宏观的角度只看数量级上的差异：如果在同一个数量级，则认为没有差异，<strong>两者在创建页面的时候，都需要新建所有 DOM 元素</strong>。</p><p>刚刚我们讨论了创建页面时的性能情况，大家可能会觉得虚拟 DOM 相比 innerHTML 没有优势可言。别着急，接下来我们看看它们在更新页面时的差异。</p><h3 id="更新页面" tabindex="-1">更新页面 <a class="header-anchor" href="#更新页面" aria-label="Permalink to &quot;更新页面&quot;">​</a></h3><ul><li><p>1、innerHTML</p><p>重新构建 HTML 字符串，重新设置 DOM 元素的 innerHTML 属性(哪怕只更改一个文字，也要重新设置 innerHTML)。重新设置 innerHTML 属性就等价于销毁所有旧的 DOM 元素，再全量创建新的 DOM 元素。</p><p>特点: <strong>全量更新</strong>，页面越大，更新时的性能消耗越大。</p></li><li><p>2、虚拟 DOM 重新创建 JavaScript 对象，需要对比新旧虚拟 DOM，找到变化的元素并更新它。 在更新页面时，虚拟 DOM 在 JavaScript 层面的运算要比创建页面时多出一个 Diff 的性能消耗，然而它毕竟也是 JavaScript 层面的运算，所以不会产生数量级的差异。</p><p>特点: <strong>按需更新</strong>，无论页面多大，只会更新变化的内容</p></li></ul><p>下图直观地对比了虚拟 DOM 和 innerHTML 在更新页面时的性能</p><p><img src="'+o+'" alt="An image"></p><p>基于上述分析，我们粗略的总结一下 innerHTML、虚拟 DOM 在更新页面时的性能(从心智负担、可维护性、性能三方面)，如下图所示：</p><p><img src="'+r+`" alt="An image"></p><div class="tip custom-block"><p class="custom-block-title">总结</p><p>1、innerHTML： 编写页面的过程通过拼接字符串来实现，但字符串拼接总归是有一定心智负担的(避免拼接错误等)。如果模板很大，更新页面的性能更差，尤其是在只有少量更新时。另外可维护性不强(需重复拼接字符串)</p><p>2、虚拟 DOM: 心智负担小，可维护性强，性能虽然比不上极致优化的原生 JavaScript，但在保证心智负担和可维护性的前提下相当不错。</p></div><h2 id="运行时" tabindex="-1">运行时 <a class="header-anchor" href="#运行时" aria-label="Permalink to &quot;运行时&quot;">​</a></h2><p>比如框架提供 <code>Render</code> 函数，接收一个树型结构的数据对象，该函数会根据该对象递归地将数据渲染成 dom 元素。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Render</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">root</span><span style="color:#E1E4E8;">) { </span><span style="color:#6A737D;">// 定义</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">el</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">createElement</span><span style="color:#E1E4E8;">(obj.tag)</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> obj.children </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;string&#39;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">text</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> document.</span><span style="color:#B392F0;">createTextNode</span><span style="color:#E1E4E8;">(obj.children)</span></span>
<span class="line"><span style="color:#E1E4E8;">    el.</span><span style="color:#B392F0;">appendChild</span><span style="color:#E1E4E8;">(text)</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 递归调用 Render，使用 el 作为 root 参数</span></span>
<span class="line"><span style="color:#E1E4E8;">    obj.children.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">child</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Render</span><span style="color:#E1E4E8;">(child, el))</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">//将元素添加到root</span></span>
<span class="line"><span style="color:#E1E4E8;">  root.</span><span style="color:#B392F0;">appendChild</span><span style="color:#E1E4E8;">(el)</span></span>
<span class="line"><span style="color:#E1E4E8;">} </span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">obj</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  tag: </span><span style="color:#9ECBFF;">&#39;div&#39;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  children: [</span></span>
<span class="line"><span style="color:#E1E4E8;">    { tag: </span><span style="color:#9ECBFF;">&#39;span&#39;</span><span style="color:#E1E4E8;">, children: </span><span style="color:#9ECBFF;">&#39;hello world&#39;</span><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#E1E4E8;">  ]</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"><span style="color:#B392F0;">Render</span><span style="color:#E1E4E8;">(obj, document.body) </span><span style="color:#6A737D;">// 调用</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这个 <code>Render</code> 函数，标志着这个框架就是一个纯运行时的框架。</p><div class="warning custom-block"><p class="custom-block-title">缺点:</p><ul><li>1、手写树型结构的数据对象太麻烦，而且不直观。</li><li>2、不能支持用类似于 <code>HTML</code> 标签的方式描述树型结构的数据对象</li></ul></div><h2 id="运行时-编译时" tabindex="-1">运行时 + 编译时 <a class="header-anchor" href="#运行时-编译时" aria-label="Permalink to &quot;运行时 + 编译时&quot;">​</a></h2><p>引入 <code>Compiler</code> 函数首先把 <code>HTML</code> 标签编译成树型结构的数据对象，再让用户调用 <code>Render</code> 函数。</p><p><img src="`+c+`" alt="An image"></p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">html</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">\`</span></span>
<span class="line"><span style="color:#9ECBFF;">  &lt;div&gt;</span></span>
<span class="line"><span style="color:#9ECBFF;">    &lt;span&gt;hello world&lt;/span&gt;</span></span>
<span class="line"><span style="color:#9ECBFF;">  &lt;/div&gt;</span></span>
<span class="line"><span style="color:#9ECBFF;">\`</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">obj</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Compiler</span><span style="color:#E1E4E8;">(html)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">//再调用Render进行渲染</span></span>
<span class="line"><span style="color:#B392F0;">Render</span><span style="color:#E1E4E8;">(obj, document.body)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>此时我们的框架就变成了一个 <code>运行时 + 编译时</code> 的框架：</p><div class="tip custom-block"><p class="custom-block-title">特点</p><ul><li>1、它既支持运行时，用户可以直接提供数据对象从而无需编译。</li><li>2、又支持编译时，用户可以提供 <code>HTML</code> 字符串，我们将其编译为数据对象后再交给运行时处理。</li></ul></div><h2 id="编译时" tabindex="-1">编译时 <a class="header-anchor" href="#编译时" aria-label="Permalink to &quot;编译时&quot;">​</a></h2><p>把一段 <code>HTML</code> 字符串编译为<strong>命令式</strong>代码的过程。此时只需要 <code>Compiler</code> 函数即可， 不在需要 <code>Render</code>， 此时就变成了一个纯编译时的框架。</p><p><img src="`+t+'" alt="An image"></p><div class="warning custom-block"><p class="custom-block-title">缺点:</p><ul><li>1、不需要任何运行时，直接编译成可执行的 <code>javascript</code>代码， 性能可能会更好。</li><li>2、这种做法有损灵活性，即用户的内容必须编译后才能用。</li></ul></div><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>1、<code>Vue.js</code> 封装了<code>命令式</code>的逻辑，而对外暴露了<code>声明式</code>的接口。</li><li>2、<code>Vue.js</code> 保持了<code>运行时 + 编译时</code>，在保证灵活的基础上能够尽可能地去优化。在编译优化阶段，你会看到 <code>Vue.js</code> 在保留运行时的情况下，其性能甚至不输纯编译时。</li><li>3、设计原则: <strong>在保证可维护性的基础上，尽可能的减少性能的损耗</strong></li></ul>',64),d=[E];function y(u,b,m,g,h,F){return a(),n("div",null,d)}const B=s(i,[["render",y]]);export{M as __pageData,B as default};
